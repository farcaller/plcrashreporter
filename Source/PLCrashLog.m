/*
 * Author: Landon Fuller <landonf@plausiblelabs.com>
 *
 * Copyright (c) 2008 Plausible Labs Cooperative, Inc.
 * All rights reserved.
 */

#import "PLCrashLog.h"
#import "CrashReporter.h"

#import "crash_report.pb-c.h"

struct _PLCrashLogDecoder {
    Plcrash__CrashReport *crashReport;
};

@interface PLCrashLog (PrivateMethods)

- (void) populateError: (NSError **) error 
             errorCode: (PLCrashReporterError) code
           description: (NSString *) description;

- (Plcrash__CrashReport *) decodeCrashData: (NSData *) data error: (NSError **) outError;

@end

/**
 * Provides decoding of crash logs generated by the PLCrashReporter framework.
 */
@implementation PLCrashLog

/**
 * Initialize with the provided crash log data. On error, nil will be returned, and
 * an NSError instance will be provided via @a error, if non-NULL.
 *
 * @param encodedData Encoded plcrash crash log.
 * @param outError If an error occurs, this pointer will contain an NSError object
 * indicating why the crash log could not be parsed. If no error occurs, this parameter
 * will be left unmodified. You may specify NULL for this parameter, and no error information
 * will be provided.
 *
 * @par Designated Initializer
 * This method is the designated initializer for the PLCrashLog class.
 */
- (id) initWithData: (NSData *) encodedData error: (NSError **) outError {
    if ((self = [super init]) == nil)
        return nil;


    /* Allocate the struct and attempt to parse */
    _decoder = malloc(sizeof(_PLCrashLogDecoder));
    _decoder->crashReport = [self decodeCrashData: encodedData error: outError];

    if (_decoder->crashReport == NULL) {
        [self release];
        return nil;
    }

    return self;
}

- (void) dealloc {
    /* Free the decoder state */
    if (_decoder != NULL) {
        if (_decoder->crashReport != NULL) {
            protobuf_c_message_free_unpacked((ProtobufCMessage *) _decoder->crashReport, &protobuf_c_system_allocator);
        }

        free(_decoder);
    }
    [super dealloc];
}

#if 0
- (void) unpack {
    /* Check the file magic. The file must be large enough for the value + version + data */
    STAssertTrue(statbuf.st_size > strlen(PLCRASH_LOG_FILE_MAGIC) + sizeof(uint8_t), @"File is too small for magic + version + data");
    STAssertTrue(memcmp(buf, PLCRASH_LOG_FILE_MAGIC, strlen(PLCRASH_LOG_FILE_MAGIC)) == 0, @"File does not start with magic string");
    STAssertEquals(((uint8_t *) buf)[strlen(PLCRASH_LOG_FILE_MAGIC)], (uint8_t)PLCRASH_LOG_FILE_VERSION, @"File version is not equal to 0");
    
    /* Try to read the crash report */
    Plcrash__CrashReport *crashReport;
    crashReport = plcrash__crash_report__unpack(&protobuf_c_system_allocator, statbuf.st_size, buf + strlen(PLCRASH_LOG_FILE_MAGIC) + sizeof(uint8_t));
    
    /* If reading the report didn't fail, test the contents */
    STAssertNotNULL(crashReport, @"Could not decode crash report");
    if (crashReport != NULL) {
        /* Test the report */
        [self checkSystemInfo: crashReport];
        [self checkThreads: crashReport];
        [self checkException: crashReport];
        
        /* Free it */
        protobuf_c_message_free_unpacked((ProtobufCMessage *) crashReport, &protobuf_c_system_allocator);
    }
}
#endif

@end


/**
 * @internal
 * Private Methods
 */
@implementation PLCrashLog (PrivateMethods)

/**
 * Decode the crash log message.
 *
 * @warning MEMORY WARNING. The caller is responsible for deallocating th ePlcrash__CrashReport instance
 * returned by this method via protobuf_c_message_free_unpacked().
 */
- (Plcrash__CrashReport *) decodeCrashData: (NSData *) data error: (NSError **) outError {
    const struct PLCrashLogFileHeader *header;
    const void *bytes;

    bytes = [data bytes];
    header = bytes;

    /* Verify that the crash log is sufficently large */
    if (sizeof(struct PLCrashLogFileHeader) >= [data length]) {
        [self populateError: outError errorCode: PLCrashReporterErrorCrashReportInvalid description: NSLocalizedString(@"Could not decode truncated crash log", @"Crash log decoding error message")];
        return NULL;
    }

    /* Check the file magic */
    if (memcmp(header->magic, PLCRASH_LOG_FILE_MAGIC, strlen(PLCRASH_LOG_FILE_MAGIC)) != 0) {
        [self populateError: outError errorCode: PLCrashReporterErrorCrashReportInvalid description: NSLocalizedString(@"Could not decode invalid crash log header", @"Crash log decoding error message")];
        return NULL;
    }

    /* Check the version */
    if(header->version != PLCRASH_LOG_FILE_VERSION) {
        [self populateError: outError errorCode: PLCrashReporterErrorCrashReportInvalid description: [NSString stringWithFormat: NSLocalizedString(@"Could not decode unsupported crash report version: %d", @"Crash log decoding message"), header->version]];
        return NULL;
    }

    Plcrash__CrashReport *crashReport = plcrash__crash_report__unpack(&protobuf_c_system_allocator, [data length] - sizeof(struct PLCrashLogFileHeader), header->data);
    if (crashReport == NULL) {
        [self populateError: outError errorCode: PLCrashReporterErrorCrashReportInvalid description: NSLocalizedString(@"An unknown error occured decoding the crash report", @"Crash log decoding error message")];
        return NULL;
    }

    return crashReport;
}


/**
 * Populate an NSError instance with the provided information.
 *
 * @param error Error instance to populate. If NULL, this method returns
 * and nothing is modified.
 * @param code The error code corresponding to this error.
 * @param description A localized error description.
 * @param cause The underlying cause, if any. May be nil.
 */
- (void) populateError: (NSError **) error 
             errorCode: (PLCrashReporterError) code
           description: (NSString *) description
{
    NSMutableDictionary *userInfo;
    
    if (error == NULL)
        return;
    
    /* Create the userInfo dictionary */
    userInfo = [NSDictionary dictionaryWithObjectsAndKeys:
                    description, NSLocalizedDescriptionKey,
                    nil
               ];
    
    *error = [NSError errorWithDomain: PLCrashReporterErrorDomain code: code userInfo: userInfo];
}

@end